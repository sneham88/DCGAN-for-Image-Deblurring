# -*- coding: utf-8 -*-
"""training utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rklan_ERtE8Cs41QpexsCxlvjK_55IqF

### Import Libraries
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

import torch
import torch.nn as nn
import torch.nn.functional as F

import tensorflow as tf
from tensorflow.keras import layers
from tensorflow.keras.models import Model, Sequential
from keras.callbacks import TensorBoard
from skimage.metrics import peak_signal_noise_ratio, structural_similarity


from glob import glob
import os

# Function to load images in batches
def load_images_in_batches(image_paths, batch_size):
    for i in range(0, len(image_paths), batch_size):
        batch_images = []
        for img_path in image_paths[i:i+batch_size]:
            img = cv2.imread(img_path, cv2.IMREAD_COLOR)  # Read image
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB
            img = cv2.resize(img, (256, 256))  # Resize to 256x256
            img = img.astype(np.float32) / 127.5 - 1  # Normalizes to [-1, 1]
            batch_images.append(img)
        yield np.array(batch_images)

"""#### Define PSNR and SSIM Helper"""

def compute_psnr_ssim(generated_batch, sharp_batch):
    psnr_scores, ssim_scores = [], []

    gen_images = ((generated_batch.numpy() + 1.0) * 127.5).astype("uint8")
    sharp_images = ((sharp_batch.numpy() + 1.0) * 127.5).astype("uint8")

    for gen, sharp in zip(gen_images, sharp_images):
        psnr = peak_signal_noise_ratio(sharp, gen, data_range=255)
        ssim = structural_similarity(sharp, gen, data_range=255, channel_axis=-1)
        psnr_scores.append(psnr)
        ssim_scores.append(ssim)

    return np.mean(psnr_scores), np.mean(ssim_scores)

# Function for denormalization
def denormalize_images(images):
    """Convert images from range [-1,1] back to [0,255] for visualization."""
    if isinstance(images, tf.Tensor):  # Convert Tensor to NumPy if needed
        images = images.numpy()

    images = (images + 1.0) * 127.5  # Correct scaling from [-1,1] to [0,255]
    return np.clip(images, 0, 255).astype(np.uint8)  # Ensure valid range

# Function for plotting training at each epoch
def generate_and_plot_images(model, epoch, test_input):
    """
    Generate images using the generator and plot them.
    """
    predictions = model(test_input, training=False)  # Generate images

    # Debug: Print min/max values before denormalization
    print(f"Before denormalization: min={tf.reduce_min(predictions).numpy()}, max={tf.reduce_max(predictions).numpy()}")

    predictions = denormalize_images(predictions)  # Convert [-1,1] â†’ [0,255]

    # Debug: Print min/max values after denormalization
    print(f"After denormalization: min={np.min(predictions)}, max={np.max(predictions)}")

"""#### END"""